{
  "name": "collections/blog/posts/bb0ca99e76bc",
  "__resolveType": "blog/loaders/Blogpost.ts",
  "post": {
    "authors": [
      {
        "name": "Leandro Borges",
        "email": "leandro@decocms.com",
        "avatar": "https://assets.decocache.com/decocms/a840b1da-3c25-46cb-88a0-9c727a24644a/Screenshot-2025-08-11-at-11.00.30.png"
      }
    ],
    "categories": [
      {
        "name": "Product",
        "slug": "product"
      }
    ],
    "imageCarousel": {
      "banners": []
    },
    "extraProps": [],
    "aggregateRating": {
      "@type": "AggregateRating"
    },
    "review": [],
    "contentRating": [],
    "interactionStatistic": {
      "@type": "InteractionCounter",
      "video": null,
      "image": null
    },
    "title": "Prototype in Chat, Ship in Code: The Dual Surface Problem",
    "excerpt": "This is the dual surface problem: the interface that makes AI accessible to business users is fundamentally different from the interface that makes AI governable for production systems.",
    "date": "2025-09-23",
    "slug": "ai-cms",
    "content": "<p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">The demo goes perfectly. Your product manager pulls up a chat interface, types \"analyze last quarter's conversion funnel and suggest three optimization experiments,\" and watches as the AI agent queries your analytics, cross-references user behavior data, and generates a formatted report with actionable recommendations. The room nods. Everyone's excited.</span><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">Three months later, that same workflow is still a demo. IT won't approve the data connections. Finance wants spend controls. Legal needs audit trails. The agent that took five minutes to prototype now requires weeks of infrastructure work to run safely in production.</span></p><p></p><p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">This is the dual surface problem: the interface that makes AI accessible to business users is fundamentally different from the interface that makes AI governable for production systems.</span></p><p></p><h2><strong><span style=\"color: rgb(0, 0, 0); font-size: 16pt\">Why now</span></strong></h2><p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">Two shifts have made this tension unavoidable. First, conversational interfaces have democratized AI prototyping—anyone can describe a workflow in natural language and see it work immediately. Second, enterprises are discovering that production AI requires the same operational rigor as any other business-critical system: permissions, observability, cost controls, and compliance.</span></p><p></p><p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">The gap between \"works in chat\" and \"works in production\" has become the primary bottleneck for AI adoption. Teams that can prototype in minutes find themselves stuck for months trying to productionize their workflows.</span><br></p><h2><strong><span style=\"color: rgb(0, 0, 0); font-size: 16pt\">What we mean by \"dual surface\"</span></strong></h2><p><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">A dual surface system provides two distinct interfaces to the same underlying runtime: a conversational interface optimized for rapid prototyping and iteration, and a programmatic interface optimized for governance, observability, and scale.</span></p><p><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">The key insight is that these aren't separate systems connected by export/import.</span></p><p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">It's a different view into the same code repository, where a workflow prototyped in chat becomes immediately available as governed, traceable, and scalable code—without translation or rebuilding.</span></p><p><br></p><h2><strong><span style=\"color: rgb(0, 0, 0); font-size: 16pt\">How we got here</span></strong></h2><p><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">The pattern isn't new. Content management evolved from static HTML to WYSIWYG editors to headless CMSs precisely because different users needed different interfaces to the same content. Developers wanted APIs and version control; content creators wanted visual editors and preview modes.</span></p><p><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">AI workflows are following a similar path. Early AI tools forced everyone into either pure code (accessible only to engineers) or pure chat (impossible to govern). The breakthrough comes from recognizing that the same workflow needs to be accessible through both surfaces simultaneously, with the appropriate guardrails for each context.</span></p><p><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">Database systems solved this decades ago—the same data accessible through SQL for developers and GUIs for analysts, with consistent permissions and audit trails across both interfaces.</span></p><p><br></p><h2><strong><span style=\"color: rgb(0, 0, 0); font-size: 16pt\">What it actually does</span></strong></h2><p><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">A dual surface system maintains a single source of truth for workflow definitions, permissions, and execution history while presenting different interaction models. In the chat interface, users describe workflows in natural language, test them with sample data, and iterate rapidly. The system translates these descriptions into structured workflow definitions.</span></p><p><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">In the code interface, engineers access the same workflows through typed APIs, add error handling and retry logic, configure deployment targets, and set up monitoring. Changes made in either interface immediately reflect in the other, but with appropriate validation and approval gates.</span></p><p><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">The runtime itself remains constant—the same execution engine, the same data connections, the same permission model. Only the interaction paradigm changes based on the user's role and the task's requirements.</span></p><p><br></p><h2><strong><span style=\"color: rgb(0, 0, 0); font-size: 16pt\">Chat versus code—the real shift</span></strong></h2><p><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">The traditional approach treats prototyping and production as separate phases: build a proof of concept, then rebuild it \"properly\" for production. This creates a handoff problem where business context gets lost in translation and engineering effort gets duplicated.</span></p><p><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">The dual surface approach treats prototyping and production as different views of the same system. Business users prototype workflows that immediately inherit production-grade infrastructure—logging, permissions, cost controls, and observability. Engineers can then harden these workflows without starting from scratch, adding the operational rigor that production demands while preserving the business logic that users defined.</span></p><p><br></p><h2><strong><span style=\"color: rgb(0, 0, 0); font-size: 16pt\">What good looks like</span></strong></h2><p><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">Production-ready dual surface systems provide immediate traceability—every chat interaction generates the same audit trail as programmatic API calls. Permissions work consistently across both interfaces, so a user who can prototype a workflow in chat automatically has the right level of access when that workflow runs in production.</span></p><p><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">Cost controls operate at the workflow level, not the interface level. Whether triggered through chat or code, the same spending limits and approval gates apply. Observability spans both surfaces—you can debug a workflow that was prototyped in chat using the same tools you'd use for any other production system.</span></p><p><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">Version control becomes automatic. Chat interactions create versioned workflow definitions that engineers can review, modify, and deploy through standard development practices.</span></p><p><br></p><h2><strong><span style=\"color: rgb(0, 0, 0); font-size: 16pt\">How to adopt without boiling the ocean</span></strong></h2><p><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">Start by identifying one workflow that business users prototype repeatedly—usually something involving data analysis, content generation, or process automation. Implement the chat interface first, but ensure it writes to structured workflow definitions rather than executing arbitrary code.</span></p><p><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">Add the programmatic interface incrementally. Begin with read-only access so engineers can inspect and understand workflows created through chat. Then add the ability to modify and extend these workflows through code, with changes flowing back to the chat interface.</span></p><p><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">Governance comes last but matters most. Implement permission boundaries, cost controls, and audit logging that work consistently across both interfaces before expanding to additional use cases.</span></p><p><br></p><h2><strong><span style=\"color: rgb(0, 0, 0); font-size: 16pt\">Roles you'll need</span></strong></h2><p><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">Business users become workflow authors, describing processes and iterating on logic through conversational interfaces. They own the \"what\" and \"why\" of automation but don't need to understand implementation details.</span></p><p><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">Engineers become workflow operators, adding production rigor to business-defined processes. They handle error cases, performance optimization, and integration with existing systems. The handoff becomes collaborative rather than adversarial because both roles work with the same underlying workflows.</span></p><p><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">Platform teams provide the dual surface infrastructure itself—the runtime that makes chat prototypes immediately governable and code implementations immediately accessible to business users.</span></p><p><br></p><h2><strong><span style=\"color: rgb(0, 0, 0); font-size: 16pt\">Anti-patterns to avoid</span></strong></h2><p><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">Don't build separate systems for chat and code that require manual synchronization. The power comes from shared state, not integration between distinct tools. Don't assume that chat interfaces can skip governance—business users need guardrails, not unlimited access. Don't treat the programmatic interface as a \"real\" system and the chat interface as a toy—both need to be production-capable from day one.</span></p><p><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">Avoid the temptation to make the chat interface too powerful or the code interface too restrictive. Each should excel at its primary use case while maintaining consistency with the other.</span></p><p><br></p><h2><strong><span style=\"color: rgb(0, 0, 0); font-size: 16pt\">Build vs buy</span></strong></h2><p><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">Building dual surface systems requires significant infrastructure investment—conversational AI for the chat interface, workflow orchestration for the runtime, and developer tooling for the code interface. Most teams should start with existing platforms that provide this foundation.</span></p><p><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">The build decision makes sense when your workflows are highly specialized or when you need deep integration with proprietary systems. The buy decision makes sense when you want to focus on business logic rather than infrastructure, especially in the early stages of AI adoption.</span></p><p><br></p><h2><strong><span style=\"color: rgb(0, 0, 0); font-size: 16pt\">The bigger shift</span></strong></h2><p><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">The dual surface pattern points toward a broader transformation in how we think about business software. Instead of forcing users to adapt to rigid interfaces, systems can provide multiple interaction paradigms while maintaining operational consistency underneath.</span></p><p><br></p><p><span style=\"color: rgb(0, 0, 0); font-size: 11pt\">This isn't just about AI—it's about making powerful automation accessible to business users while keeping it governable for production systems. The teams that master dual surface design will build AI that actually ships, not just demos.</span></p>",
    "seo": {
      "image": "https://assets.decocache.com/decocms/d8e72785-7bc8-45ec-9668-f8e0820d680e/The-Dual-Surface-Problem---Cover.png"
    },
    "readTime": 8
  }
}
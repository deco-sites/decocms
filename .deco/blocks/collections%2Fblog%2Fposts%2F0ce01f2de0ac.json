{
  "name": "collections/blog/posts/0ce01f2de0ac",
  "__resolveType": "blog/loaders/Blogpost.ts",
  "post": {
    "authors": [
      {
        "name": "Rafael Crespo",
        "email": "rafael@decocms.com",
        "jobTitle": "Co-founder",
        "avatar": "https://assets.decocache.com/decocms/d377d0fc-343d-4f45-84aa-c7e1da1beaf0/Luciano-Junior-1.png"
      }
    ],
    "categories": [
      {
        "name": "Product",
        "slug": "product"
      }
    ],
    "imageCarousel": {
      "banners": []
    },
    "extraProps": [],
    "aggregateRating": {
      "@type": "AggregateRating"
    },
    "review": [],
    "contentRating": [],
    "interactionStatistic": {
      "@type": "InteractionCounter",
      "image": null,
      "video": null
    },
    "image": "https://assets.decocache.com/decocms/617f7695-bdf9-40a4-84fe-c25c60077286/blog.png",
    "seo": {
      "image": "https://assets.decocache.com/decocms/052eb478-dbc4-420b-b941-75c52b449b70/blog-post2-seo.png",
      "title": "Introducing deco’s MCP Mesh: a control plane for MCP in production",
      "description": "The MCP Mesh solves the immediate infrastructure problems teams hit when MCP moves into production: sprawl, missing visibility, inconsistent policies, and costs without attribution. More importantly, it makes the next step practical: turning one-off agent setups into reusable capabilities that can be packaged, governed, and shared—without rewriting integrations every time."
    },
    "date": "2025-12-22",
    "slug": "mcp-mesh",
    "content": "<p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">In the previous post, we argued that scaling AI inside an enterprise is an operating problem: how tools and data are exposed, controlled, observed, and paid for as usage spreads across teams and environments.</span></p><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">We saw this firsthand throughout 2025 while building alongside design partners who were early to agentic workflows. In almost every case, the pattern was the same: a few proof-of-concepts that looked promising, followed by the hard part—shipping agents that </span><strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">close the loop</span></strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\"> and deliver reliable outcomes in real systems. That’s where the bottlenecks showed up repeatedly: connection sprawl, missing observability, inconsistent permissions, and rising costs without attribution.</span></p><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Those constraints pushed us toward </span><strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">context infrastructure</span></strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">: treating MCP traffic as a first-class production surface. That’s what the MCP Mesh is. We originally built it as an internal layer to ship these systems with customers. This release turns that layer into a </span><strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">self-hosted</span></strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\"> component and shares it with the open-source community—because many platform teams seem to be running into the same issues.</span></p><hr><p></p><h2>Why teams end up paying an “integration tax”</h2><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Once you move beyond a few PoCs, you start paying for MCP integrations in three places at once:</span></p><ul><li><p><strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Engineering time:</span></strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\"> fragile, duplicated integration logic spread across codebases</span></p></li><li><p><strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Operations:</span></strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\"> debugging without a single source of truth</span></p></li><li><p><strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Risk + cost:</span></strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\"> policies enforced inconsistently (or not at all), no attribution, weak guardrails</span></p></li></ul><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">An MCP Mesh is our answer to that: a self-hosted control plane that sits between your apps/agents and your MCP servers, so you can manage MCP traffic like any other production surface—with routing, access control, observability, and runtime strategies.</span></p><hr><p></p><h2>What the MCP Mesh is (and where it sits)</h2><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">[Diagram: MCP clients → MCP Mesh → MCP servers]</span></p><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">The MCP Mesh sits between your applications (agents, internal tools, IDE clients) and your MCP servers.</span></p><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Your code integrates with </span><strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">one endpoint</span></strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">. Behind that endpoint, the mesh can call any MCP server—GitHub, Jira, internal databases, custom tools, even LLM providers exposed as MCP—while centralizing the concerns you don’t want reimplemented across every app:</span></p><ul><li><p><strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Routing + execution:</span></strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\"> which MCP to call, how to authenticate, how to retry, how to fail</span></p></li><li><p><strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Policy enforcement:</span></strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\"> who (team/user/agent) can access which tools and data</span></p></li><li><p><strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Observability:</span></strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\"> logs, traces, latency, errors across MCP calls and model calls</span></p></li><li><p><strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Cost + rate controls:</span></strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\"> attribution and enforceable guardrails</span></p></li><li><p><strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Runtime strategies:</span></strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\"> different ways to expose tools and context depending on latency/cost/accuracy needs</span></p></li></ul><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">This is the difference between “we connected tools to agents” and “we can operate tool access in production.”</span></p><hr><p></p><h2>Core primitives (what it’s built from)</h2><h3>What teams need as MCP moves into production</h3><h4>Phase 1: Connect &amp; Debug</h4><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">First you need it to run end-to-end. Most teams do this with ad hoc integration logic. The mesh is about making that step fast </span><em><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">without</span></em><span style=\"color: rgb(0, 0, 0); font-size: 10pt\"> creating long-term sprawl.</span><br></p><p><strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Deploy anywhere</span></strong></p><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">The mesh is self-hosted by design with zero-config for local setup.&nbsp;</span></p><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Other typical setups:</span></p><ul><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Docker Compose (SQLite or Postgres)</span></p></li><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Bun/Node runtime</span></p></li><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Kubernetes via Helm&nbsp;</span><br></p></li></ul><p><strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Connection consolidation (and dev-time tunneling)</span></strong></p><h3><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Instead of managing eight MCP server connections in your client—each with separate config and auth—you configure one endpoint. All your organization’s MCP traffic flows through it.We also support dev-time tunneling (</span><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"http://deco.host\"><span style=\"color: rgb(24, 128, 56); font-size: 10pt\">deco.host</span></a><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">) so you can run and test MCP servers locally during development without publishing them.</span><br><br></h3><h4>Phase 2: Control</h4><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Once it works, it needs to work reliably, securely, and predictably.</span></p><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">This is where teams typically discover they don’t just need “an MCP aggregator”—they need a control plane.</span><br></p><p><strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Observability</span></strong></p><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Without centralized observability, you’re guessing:</span></p><ul><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">no audit trail</span></p></li><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">hard-to-debug failures</span></p></li><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">limited ability to attribute latency/costs</span></p></li><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">avoidable compliance risk</span></p></li></ul><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">With the mesh: unified logging of model calls and MCP tool invocations, latency tracking per provider, error rates, and traces across multi-step workflows.</span></p><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">When something breaks, you can see the chain: </span><em><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">which MCP call failed, how long it took, what it returned, and what happened next.</span></em><br></p><p><strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Cost Control</span></strong></p><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Token-level cost tracking by team/user/agent/application, plus guardrails like budget caps and rate limits.</span><br></p><p><strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Governance &amp; Security</span></strong></p><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Role-based access control at the model, MCP, and tool level. Policies enforced at the control plane, not duplicated across apps. Audit logs suitable for regulated environments.</span></p><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">The goal is to make “safe by default” the easiest path.</span><br><br></p><h4>Phase 3: Optimize (runtime strategies as gateways)</h4><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Once agents run in production, a new problem shows up: they work, but they get slow and expensive as tool surfaces grow.</span><br></p><p><strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">The Tool Discovery Problem</span></strong></p><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">The naive approach is to describe every tool to the model on every call. That’s workable with a small toolset. It breaks when you have dozens of MCP servers and hundreds of tools: context balloons, latency climbs, and tool selection gets harder.</span></p><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Concrete example: </span><strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">50 MCPs × 10 tools each = 500 tools</span></strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">. Even if descriptions are short, you can spend a meaningful chunk of the context window just listing capabilities—paying in tokens and time, often with worse tool selection.</span><br></p><p><strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Gateways: one endpoint, different exposure strategies</span></strong></p><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Internally, we started modeling “runtime strategies” as gateway implementations.</span></p><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">A gateway still gives you one endpoint (usable from Cursor, Claude Desktop, internal agents, etc.), but it changes how tools are exposed:</span></p><ul><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Full context mode: expose everything, always. Simple, deterministic, best for small tool surfaces.</span></p></li><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Smart tool selection: a two-stage approach that narrows the toolset before execution.</span></p></li><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Code execution mode: instead of describing tools in detail, let the model write code against a constrained interface and run it in a sandbox (useful for larger surfaces and multi-step logic).</span></p></li></ul><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Gateways are configurable and extensible. You can create new gateways, experiment with different strategies, and adopt whichever one fits your latency/cost/accuracy constraints.</span><br><br></p><h4>Phase 4 — Compose &amp; extend (from gateways to durable capabilities)</h4><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Over time, teams stop thinking in one-off agents and start building reusable components. Two things matter here:</span><br></p><p><strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Virtual MCPs: bundling and curation</span></strong></p><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Because gateways can choose what to expose, they can also become a way to curate and bundle tools from multiple MCP servers into a single “virtual MCP.”</span></p><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">That’s useful even before you have a full app framework:</span></p><ul><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">bundle the few tools an agent should have (and nothing else)</span></p></li><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">present stable interfaces even as underlying MCP servers evolve</span></p></li><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">create purpose-built toolsets per team or environment</span></p></li></ul><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">This bundling/curation logic is also how we think about MCP apps (coming soon): packaging durable capabilities that can be shared across teams—and eventually distributed more broadly through a store.</span><br></p><p><strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Bindings: keep apps stable while tools change</span></strong></p><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">At enterprise scale, tools change constantly—vendors, internal systems, schemas, ownership. If every app is coupled to a specific MCP implementation, your agentic layer becomes brittle.</span></p><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Bindings define contracts for common capability types (collections, agents, workflows), so apps can target the contract instead of the provider. Swap the MCP behind the interface, keep your UIs and workflows intact.</span></p><ul><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Collection bindings: a standard interface for “things that contain other things.”</span></p></li><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Agent bindings: a standard interface for AI agents, independent of provider.</span></p></li><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Workflow bindings: a standard interface for deterministic multi-tool orchestration.</span></p></li></ul><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">(We’ll go deeper on agent/workflow bindings in a future post.)</span><br></p><p><strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Multi-tenancy</span></strong></p><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">With contracts and shared interfaces, the same application code can work across teams with different permissions and toolsets—without branching your system into per-team variants.</span><br></p><p><strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">The middle path: consolidate what you must, stay flexible where you can</span></strong></p><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">There’s a tension we keep seeing: build everything yourself, or integrate a dozen tools and live with sprawl.</span></p><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Our approach is to centralize the infrastructure you shouldn’t rebuild repeatedly—connections, governance, observability, routing, cost controls—while keeping the edges composable. When a strong MCP server appears (vendor, internal, open source), you can adopt it. When you need something domain-specific, you can build it. When implementations change, your contracts can stay stable.</span></p><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">The interesting part is what happens over time: your investment compounds instead of fragmenting.</span></p><hr><p></p><h2>Product Roadmap</h2><p><strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Available Now (Q4 2025):</span></strong></p><ul><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">MCP aggregation + proxy</span></p></li><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Tool logs; rate limits per user/MCP</span></p></li><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">RBAC + permissions</span></p></li><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Registry integration with verified MCPs</span></p></li><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Copy to Cursor / Claude Code / Windsurf</span></p></li><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Zero-config local setup</span></p></li><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Self-hosted infra</span></p></li><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Docker Compose + Helm Chart (Kubernetes)</span></p></li><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Runtime strategies as gateways</span></p></li><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">OAuth proxy for MCP authentication</span></p></li><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Multi-tenancy&nbsp;</span></p></li></ul><p><strong><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Coming up Q1 2026:</span></strong></p><ul><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Studio foundation: bindings for agents, workflows, views</span></p></li><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">MCP App support (virtual MCPs with QuickJS)</span></p></li><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Version history for mesh configs</span></p></li><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">NPM package runtime&nbsp;</span></p></li><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Visual workflow builder</span></p></li><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Unified wallet: cost tracking + analytics</span></p></li><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Self-optimizing runtime selection</span></p></li><li><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Prebuilt module: blogpost generator</span></p></li></ul><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Feedback from our clients and community shape this roadmap.&nbsp;</span></p><hr><h2>Get started</h2><ul><li><p><strong><em><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Try locally: (npx / bun command)</span></em></strong></p></li><li><p><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://docs.decocms.com/en/introduction/\"><strong><em><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Read docs</span></em></strong></a></p></li><li><p><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://github.com/decocms/mesh\"><strong><em><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">GitHub Repository</span></em></strong></a></p></li><li><p><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://discord.com/invite/deco-cx\"><strong><em><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Join Discord</span></em></strong></a></p></li><li><p><strong><em><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">Production evaluation: (deployment guide + contact)</span></em></strong></p></li></ul><hr><p></p><h2>Why we’re starting here</h2><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">The MCP Mesh solves the immediate infrastructure problems teams hit when MCP moves into production: sprawl, missing visibility, inconsistent policies, and costs without attribution.</span></p><p><span style=\"color: rgb(0, 0, 0); font-size: 10pt\">More importantly, it makes the next step practical: turning one-off agent setups into reusable capabilities that can be packaged, governed, and shared—without rewriting integrations every time.</span></p>",
    "title": "Introducing deco’s MCP Mesh: a control plane for MCP in production",
    "excerpt": "The MCP Mesh sits between your applications (agents, internal tools, IDE clients) and your MCP servers. Your code integrates with one endpoint. Behind that endpoint, the mesh can call any MCP server—GitHub, Jira, internal databases, custom tools, even LLM providers exposed as MCP—while centralizing the concerns you don’t want reimplemented across every app:"
  }
}